{"entries":[{"title":404,"url":"/404.html","date":null,"categories":[],"body":""},{"title":"Categories","url":"/categories.html","date":null,"categories":[],"body":""},{"title":"Tags","url":"/tags.html","date":null,"categories":[],"body":""},{"title":"About Us","url":"/about.html","date":null,"categories":[],"body":"The MicroView is the first chip-sized Arduino compatible that lets you see what your Arduino is thinking using a built-in OLED display. You’ve never seen an Arduino™ compatible like this. With a built-in OLED (Organic Light Emitting Diode Display) you can see what your Arduino is thinking without having to connect it to your computer.  No more cryptic “Hello World” LED blink sequences or shoehorning oversized displays onto your tiny Arduino™. Development is much easier when you can see what’s going on."},{"title":"Archive","url":"/archive.html","date":null,"categories":[],"body":""},{"title":"Search","url":"/search.html","date":null,"categories":[],"body":""},{"title":null,"url":"/index.html","date":null,"categories":[],"body":""},{"title":"Getting Started with MicroView","url":"/intro/getting-started.html","date":"2014-05-04 00:00:00 +1000","categories":["intro"],"body":"In order to get your MicroView up and running you’ll need the latest version of the Arduino software available from the Arduino Website. The Arduino software (also known as the Arduino IDE), lets you program you MicroView (and other Arduinos).  To get the Arduino software visit: arduino.cc/en/main/software. Use the MicroView USB programmer or FTDI cable to connect your MicroView to one of your computer’s USB ports. The MicroView USB programmer uses a special FTDI chip to convert the signals from your computer’s USB port into serial signals compatible with your MicroView. This FTDI chip requires special drivers to be installed on your computer. Head over to the FTDI site. Look on the left side for ‘Drivers,’ and then choose ‘VCP Drivers’. Now we need to determine if you need the x86 or x64 bit version of the drivers. Click on the apple icon in the top left of the screen, and choose ‘About this Mac’. Check under ‘Processor’ to see which version you have. Follow the chart below to determine which drivers to download. Download the files from the site by clicking on the link. Locate the .dmg file that was downloaded to your computer, and double click on it. If you are not sure which version of OS X you have, use the same process as before when finding the processor type. Click on the apple and choose ‘About This Mac’. You will then see Version 10.X.Y–use the 10.X to determine your system version. Continue through the installation, and wait for it to finish. Then click ‘Close.’ Your MicroView and the Arduino UNO are interchangeable but you won’t find the MicroView listed in the Arduino Software. Select “Arduino UNO” instead.      Head over to the FTDI site. Look on the left side for ‘Drivers,’ and then choose ‘VCP Drivers’.         Now we need to determine if you need the x86 or x64 bit version of the drivers. Click on the apple icon in the top left of the screen, and choose ‘About this Mac’.         Check under ‘Processor’ to see which version you have. Follow the chart below to determine which drivers to download.         Download the files from the site by clicking on the link. Locate the .dmg file that was downloaded to your computer, and double click on it. If you are not sure which version of OS X you have, use the same process as before when finding the processor type. Click on the apple and choose ‘About This Mac’. You will then see Version 10.X.Y–use the 10.X to determine your system version.         Continue through the installation, and wait for it to finish. Then click ‘Close.’   "},{"title":"General Overview of MicroView","url":"/intro/general-overview-of-microview.html","date":"2014-06-04 00:00:00 +1000","categories":["intro"],"body":" The MicroView is the first chip-sized Arduino compatible that lets you see what your Arduino is thinking using a built-in OLED display. In the heart of MicroView there is an ATMEL’s ATmega328P, 5V & 3.3V LDO and a 64x48 pixel OLED display, together with other passive components that allow the MicroView to operate without any external components other than a power supply. MicroView is 100% code compatible with Arduino Uno (ATmega328P version), meaning code that runs in Arduino Uno will also be able to run in MicroView as long as the IO pins used in the code is externally exposed in MicroView.  The SSD1306 is the controller built-in the MicroView’s OLED.  It has flexible yet complex segment and common drivers.  One requires vast knowledge on memory addressing in order to use the SSD1306 controller. MicroView’s library was written to wrap around the complexities of the SSD1306 controller, so that user can issue simple commands to control the display. Although the SSD1306 has a built-in RAM (memory) for the screen, when connected using the SPI method, ATmega328P is not able to read the RAM (memory) of the SSD1306. Therefore the software will not be able to manipulate the screen memory to perform mathematical operation on the screen memory. MicroView’s library overcome this by allocating a 384 bytes ( (64 x 48)/8 bits) of memory from ATmega328P as buffer. The library can now manipulates the buffer memory and then perform a bulk transfer from the ATmega328P’s memory to the internal memory of the SSD1306 controller.  The 384 bytes of buffer memory are declared in MicroView’s library as and are arranged in a linear form representing the following 64 x 48 pixels coordinate system.  Based on the above illustration, for example, if a user wish to plot a pixel at the position of the black dot, where X=10 and Y=2, user issue the following command: This command will then calculate the exact location of the buffer memory and set a BIT in the BYTE corresponding to the X,Y position. Diagram showing how a linear buffer memory in the ATmega328P aligns with the OLED pixels. Diagram showing the BITs in a BYTE of the buffer memory corresponding to the OLED’s X,Y position. Based on the above illustration, a pixel turned on at X=2 and Y=3 means BYTE 2 of the buffer memory has a data of 0x08 (hex).  Two pixels at X=2,Y=3 and X=2,Y=2 turned on means BYTE 2 of the buffer memory has a data of 0x0c (hex). To draw a straight line of 5 pixels starting from 10,2 to 10,6 , the following C codes show a pixel by pixel way on how to accomplish this: but in normal situation, to draw a straight line from 10,5 to 10,6 we just need a single line command: In order for the library to perform extremely fast draw (more than 100 frames per second), all drawing function in the MicroView’s library does not immediately transfer the buffer memory to the SSD1306 controller. A display() command is required to instruct the library to perform the bulk transfer from the buffer memory to the SSD1306 controller: This function take the whole buffer memory in the ATmega328P and transfer them via SPI bus (programmed at 8Mhz) to the internal memory of the SSD1306. As soon as the memory is being transferred, the pixels corresponding to the buffer memory will show up on the OLED. Display : 64x48 OLED Display Microcontroller : ATmega328P  Operating Voltage : 5V Input Voltage : 3.3VDC - 16VDC Digital I/O Pins : 12 (of which 3 provide PWM output) Analog Input Pins : 6 Flash Memory : 32 KB SRAM : 2 KB EEPROM : 1 Kilobyte Clock Speed : 16 Mhz No other components required static uint8_t screenmemory [] = {.total 384 bytes of data..};  uView.pixel(10,2);  uView.pixel(10,2); uView.pixel(10,3); uView.pixel(10,4); uView.pixel(10,5); uView.pixel(10,6);  uView.line(10,2,10,6);  uView.display(); "},{"title":"Creating Fonts for MicroView","url":"/intro/creating-fonts-for-microview.html","date":"2014-06-11 00:00:00 +1000","categories":["intro"],"body":"From the previous article General Overview of MicroView, we have covered how the MicroView library allocated 384 bytes of RAM as screen buffer from ATmega328P to perform graphic operations before transferring this block of memory to the SSD1306 OLED controller’s memory. The following diagram shows how two 5x8 pixel characters are drawn on the screen buffer.  From the diagram, “O” character appeared on ROW0 took up 5 bytes of RAM from the screen buffer in the following order: Character “A” that was shown on ROW1 took up 5 bytes of RAM from the screen buffer in the following order: A 8x16 font will take up 16 bytes of RAM from the screen buffer as shown in the next diagram:  With 8x16 font taking up RAM from screen buffer’s ROW0 and ROW1, the data of the above diagram will occupy screen buffer’s BYTE0 – BYTE7 and BYTE64 – BYTE71. Manually plotting fonts and text is a very tedious task, MicroView's library was written to remove the burden of this tedious task from the users with its built-in fonts printing functions. Displaying text in MicroView is as simple as: Although MicroView’s library includes 4 different types of font, these fonts might not suit every user’s need.  User can make their own fonts and include them into MicroView’s library by following the easy steps below: Once we understand how a character is being mapped to the MicroView’s screen buffer, we can choose to manually draw the font we like to the screen buffer or we can use a converter to convert computer’s font to bitmap and then convert the bitmap into C char definition used by the MicroView library. We have good results using Codehead’s Bitmap Font Generator to convert font into bitmap. If you have success in using other tools, please let us know so that this article can be updated.  Let’s quickly run through a few simple steps to generate a Computer’s font to bitmap. Assuming we need number 0 to 9 of Courier font in 12x24 pixel, the following steps will produce a bitmap required:  From the generated result, it is clear that there are too much space on the left of the numbers and the fonts are not large enough to fill up 12x48 cell. Let’s further enhance the effect of the font: After adjustment, we should see the following result:  This result is almost perfect except there are still empty space on the right of 9, and at the bottom of all the numbers. We can’t correct this space further because Codehead Font Generator does not allow custom Image Size, so we will correct this with an image editor later. Click File, then Export Bitmap (BMP), save the file as 12x24Font.bmp Using an image editor like Photoshop or GIMP, open the 12x24Font.bmp file, then make a selection to crop a 120 x 24 frame from the image.  If you want a WHITE text on BLACK background, you need to INVERT the color now.  Save the image and then proceed to next step. You can also save the hassle by downloading the 12x24Font.bmp already prepared by us. You have now successfully created a customised bitmap font. In order to convert the font from bitmap to C char definition, we will be using LCD Assistant for this job. Run LCD Assistant and load the 12x24Font.bmp file previously saved.  Make sure that following options are correct: Once all the option is correctly selected, click File, then save output, type in the filename as 12x24Font.h Using a text file editor, open 12x24Font.h Locate and replace with Then replace with You should get the following result: You have now successfully converted the bitmap font to C header file. Move the edited 12x24Font.h file to MicroView’s library folder. You should be able to see the 12x24Font.h in the same folder as the rest of the MicroView’s files.  Using a text file editor, open MicroView.cpp and perform the following steps: Locate Add after this line Locate Change to  Locate Change to The font that we have just added is at the 7th position starting from position 0 (font5x7) in the MicroView::fontsPointer array, therefore the new font is now fontType 7. Save MicroView.cpp once all the editing is done. Run the following sketch to test your new font: You have now successfully hacked MicroView's library with your own custom font. Convert fonts to bitmap. Generate font source file from bitmap. Add font source file to MicroView library. Select “Courier” from the Font Details drop down combo box. Enter 48 at Cell Height Enter 12 at Cell Width Enter 128 x 32 at Image Size (this Image Size need to be larger than 12x24x10(number of characters)) Enter 48 at Start Character ( 48 ASCII code is the number 0) Enter 200% at Zoom Enter or slowly increase Font Height to a suitable value, in this case, 26 Adjust the Position (X,Y) using the arrow button with option “Adjust All” selected (in this case, X=-4, Y=-1) Picture preview is the right bitmap Byte orientation has Vertical selected Width is 120 and Height is 24 Include size not selected Size endianness has Little selected Pixels/byte is 8 Table name is 12x14Font (can be any name) BYTE0 = 0x7e BYTE1 = 0x81 BYTE2 = 0x81 BYTE3 = 0x81 BYTE4 = 0x7e  BYTE64 = 0xfc BYTE65 = 0x22 BYTE66 = 0x21 BYTE67 = 0x22 BYTE68 = 0xfc  BYTE0 = 0xf8 BYTE1 = 0xfc BYTE2 = 0x06 BYTE3 = 0x03 BYTE4 = 0x03 BYTE5 = 0x06 BYTE6 = 0xfc BYTE7 = 0xf8 BYTE64 = 0xff BYTE65 = 0xff BYTE66 = 0x06 BYTE67 = 0x06 BYTE68 = 0x06 BYTE69 = 0x06 BYTE70 = 0xff BYTE71 = 0xff  uView.print(\"Hello\");  const unsigned char 12x24Font [] = {  #ifndef FONT12X24_H #define FONT12X24_H #include <avr/pgmspace.h> static const unsigned char font12x24 [] PROGMEM = { // first row defines - FONTWIDTH, FONTHEIGHT, ASCII START CHAR, TOTAL CHARACTERS, FONT MAP WIDTH HIGH, FONT MAP WIDTH LOW (2,56 meaning 256)     12,24,48,10,1,20,  };  }; #endif  //------------------------------------------------------------------------------ // File generated by LCD Assistant // http://en.radzio.dxp.pl/bitmap_converter/ //------------------------------------------------------------------------------  #ifndef FONT12X24_H #define FONT12X24_H #include <avr/pgmspace.h> static const unsigned char font12x24 [] PROGMEM = {     // first row defines - FONTWIDTH, FONTHEIGHT, ASCII START CHAR, TOTAL CHARACTERS, FONT MAP WIDTH HIGH, FONT MAP WIDTH LOW (2,56 meaning 256)     12,24,48,10,1,20,        0x1F, 0x1F, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0x1F, 0x1F, 0xFF, 0xFF, 0x9F, 0x9F, 0x9F, 0x9F,     0x07, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x9F, 0x9F, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7,     0x1F, 0x1F, 0xFF, 0xFF, 0x9F, 0x9F, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0x1F, 0x1F, 0xFF, 0xFF,     0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x1F, 0x07, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x07, 0xE7, 0xE7,     0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xFF, 0xFF, 0x7F, 0x7F, 0x9F, 0x9F, 0xE7, 0xE7, 0xE7, 0xE7,     0xFF, 0xFF, 0xFF, 0xFF, 0x87, 0x87, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0x07, 0x07, 0xFF, 0xFF,     0x1F, 0x1F, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0x1F, 0x1F, 0xFF, 0xFF, 0x1F, 0x1F, 0xE7, 0xE7,     0xE7, 0xE7, 0xE7, 0xE7, 0x1F, 0x1F, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,     0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,     0xFF, 0xFF, 0x7F, 0x7F, 0x9F, 0x9F, 0xE7, 0xE7, 0xF8, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,     0xE7, 0xE7, 0xE7, 0xE7, 0x18, 0x18, 0xFF, 0xFF, 0x1F, 0x1F, 0x61, 0x61, 0x7E, 0x7E, 0x00, 0x00,     0x7F, 0x7F, 0xFF, 0xFF, 0xE0, 0xE0, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0x1F, 0x1F, 0xFF, 0xFF,     0x00, 0x00, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0x1F, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,     0x1F, 0x1F, 0xE1, 0xE1, 0xFE, 0xFE, 0xFF, 0xFF, 0x18, 0x18, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7,     0x18, 0x18, 0xFF, 0xFF, 0xF8, 0xF8, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0x00, 0x00, 0xFF, 0xFF,     0xF8, 0xF8, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xF8, 0xF8, 0xFF, 0xFF, 0xE7, 0xE7, 0xE7, 0xE7,     0xE0, 0xE0, 0xE7, 0xE7, 0xE7, 0xE7, 0xFF, 0xFF, 0xE1, 0xE1, 0xE6, 0xE6, 0xE7, 0xE7, 0xE7, 0xE7,     0xE7, 0xE7, 0xFF, 0xFF, 0xF9, 0xF9, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xF8, 0xF8, 0xFF, 0xFF,     0xFE, 0xFE, 0xFE, 0xFE, 0xE6, 0xE6, 0xE0, 0xE0, 0xE6, 0xE6, 0xFF, 0xFF, 0xF9, 0xF9, 0xE7, 0xE7,     0xE7, 0xE7, 0xE7, 0xE7, 0xF8, 0xF8, 0xFF, 0xFF, 0xF8, 0xF8, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7,     0xF8, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xE1, 0xE1, 0xFE, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,     0xF8, 0xF8, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xF8, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xE7,     0xE7, 0xE7, 0xF9, 0xF9, 0xFE, 0xFE, 0xFF, 0xFF,  }; #endif  // Add header of the fonts here.  Remove as many as possible to conserve FLASH memory.  #include <12x24Font.h>  // Change the total fonts included #define TOTALFONTS      7  // Change the total fonts included #define TOTALFONTS      8  const unsigned char *MicroView::fontsPointer[]={     font5x7     ,font8x16     ,sevensegment     ,fontlargenumber     ,space01     ,space02     ,space03 };  const unsigned char *MicroView::fontsPointer[]={     font5x7     ,font8x16     ,sevensegment     ,fontlargenumber     ,space01     ,space02     ,space03     ,font12x24 };  #include <MicroView.h>  void setup() {   uView.begin();   uView.clear(PAGE);   uView.setFontType(7);   uView.print(\"1234\");   uView.display(); }  void loop () { } "}]}